package com.makkajai;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTree;

import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Autogenerated by ObjCToCppTranslator (c) 2015 Makkajai
 * @author Deep Shah
 * This code is licensed under MIT license (see LICENSE.txt for details)
 */
public class ObjCToCppTranslator extends ObjCBaseVisitor<Void> {

    public static final String BEGINS_WITH_2_UPPER_CASE_LETTERS = "([A-Z]{2})(.*)";
    public static final String BEGINS_WITH_UPPER_CASE_LETTERS = "([A-Z]{1})(.*)";
    public static final String END = "@end";
    public static final String COCOS2D = "cocos2d::";
    public static final String REF = "Ref";
    public static final String NS_OBJECT = "NSObject";
    public static final String CC = "CC";

    private CommonTokenStream tokens;
    private StringBuilder outputBuffer;
    private String className;
    private String superClassName;

    /**
     * Main Method
     *
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        //The input file to parse!
        ANTLRInputStream input = new ANTLRInputStream(
//                new FileInputStream("/Users/administrator/playground/projarea/math-monsters-2/makkajai-number-muncher/makkajai-ios/Makkajai/Makkajai/Utils/MakkajaiEnum.h"));
//                new FileInputStream("/Users/administrator/playground/projarea/math-monsters-2/makkajai-number-muncher/makkajai-ios/Makkajai/Makkajai/Utils/MakkajaiEnum.m"));
                new FileInputStream("/Users/administrator/playground/projarea/math-monsters-2/makkajai-number-muncher/makkajai-ios/Makkajai/Makkajai/Utils/CCSnowFall.m"));


        //The instance of the translator.
        ObjCToCppTranslator visitor = new ObjCToCppTranslator();

        //Getting the lexer.
        ObjCLexer lexer = new ObjCLexer(input);

        //This is the single most important guy.  Useful in getting the source set of tokens and stuff.
        visitor.tokens = new CommonTokenStream(lexer);

        //Parser obviously.
        ObjCParser parser = new ObjCParser(visitor.tokens);
        ParseTree tree = parser.translation_unit();

        //Output file.
        FileWriter outputFile =
//                new FileWriter("/Users/administrator/playground/projarea/math-monsters-2/makkajai-number-muncher/makkajai-ios/Makkajai/Makkajai/Utils/MakkajaiEnum.h1");
                new FileWriter("/Users/administrator/playground/projarea/math-monsters-2/makkajai-number-muncher/makkajai-ios/Makkajai/Makkajai/Utils/MakkajaiEnum.cpp");
        visitor.outputBuffer = new StringBuilder(getFileHeader())
                .append(visitor.tokens.getText());

        //This is where the entire file is parsed and appropreat callbacks are made to parse the input file.
        visitor.visit(tree);

        //All done, lets write the output buffer to the output file and get done with it!
        outputFile.write(visitor.translateLiterals(visitor.outputBuffer.toString()));
        outputFile.flush();
        outputFile.close();
    }

    @Override
    public Void visitClass_interface(ObjCParser.Class_interfaceContext ctx) {
        String classImplementationText = tokens.getText(ctx.getSourceInterval());
        System.out.println(classImplementationText);
        int startIndex = outputBuffer.indexOf(classImplementationText);
        int startEndIndexIndex = outputBuffer.lastIndexOf(END);

        if(startIndex < 0)
            return super.visitClass_interface(ctx);

        className = ctx.class_name().getText();
        superClassName = ctx.superclass_name().getText();
        int startClassNameIndex = outputBuffer.indexOf(className, startIndex);
        int startSuperClassNameIndex = outputBuffer.indexOf(superClassName, startClassNameIndex);

        int endClassNameIndex = startClassNameIndex + className.length();
        int endSuperClassNameIndex = (startSuperClassNameIndex > 0)? startSuperClassNameIndex + superClassName.length() : endClassNameIndex;

        outputBuffer
                .replace(startEndIndexIndex, startEndIndexIndex + END.length(), "\n};")
                .replace(startIndex, endSuperClassNameIndex, translateClassDecleration());

        return super.visitClass_interface(ctx);
    }

    @Override
    public Void visitClass_implementation(ObjCParser.Class_implementationContext ctx) {

        String classImplementationText = tokens.getText(ctx.getSourceInterval());
        int startIndex = outputBuffer.indexOf(classImplementationText);
        int startEndIndexIndex = outputBuffer.lastIndexOf(END);

        if(startIndex < 0)
            return super.visitClass_implementation(ctx);

        className = ctx.class_name().getText();
        int startClassNameIndex = outputBuffer.indexOf(className, startIndex);

        int endClassNameIndex = startClassNameIndex + className.length();

        outputBuffer
                .replace(startEndIndexIndex, startEndIndexIndex + END.length(), "")
                .replace(startIndex, endClassNameIndex, "");

        return super.visitClass_implementation(ctx);
    }

    @Override
    public Void visitClass_method_declaration(ObjCParser.Class_method_declarationContext ctx) {
        String methodBody = tokens.getText(ctx.getSourceInterval());

        int startMethodBody = outputBuffer.indexOf(methodBody);

        startMethodBody = outputBuffer.lastIndexOf("+", startMethodBody);

        if(startMethodBody < 0) {
            return super.visitClass_method_declaration(ctx);
        }

        ObjCParser.Method_declarationContext method_declarationContext = ctx.method_declaration();

        translateMethodDefination(method_declarationContext.method_type(),
                method_declarationContext.method_selector(), startMethodBody, "static ", false);

        return super.visitClass_method_declaration(ctx);
    }

    @Override
    public Void visitInstance_method_declaration(ObjCParser.Instance_method_declarationContext ctx) {
        String methodBody = tokens.getText(ctx.getSourceInterval());

        int startMethodBody = outputBuffer.indexOf(methodBody);

        startMethodBody = outputBuffer.lastIndexOf("-", startMethodBody);

        if(startMethodBody < 0) {
            return super.visitInstance_method_declaration(ctx);
        }

        ObjCParser.Method_declarationContext method_declarationContext = ctx.method_declaration();

        translateMethodDefination(method_declarationContext.method_type(),
                method_declarationContext.method_selector(), startMethodBody, "", false);

        return super.visitInstance_method_declaration(ctx);
    }

    @Override
    public Void visitInstance_method_definition(ObjCParser.Instance_method_definitionContext ctx) {
        String methodBody = tokens.getText(ctx.getSourceInterval());

        int startMethodBody = outputBuffer.indexOf(methodBody);

        startMethodBody = outputBuffer.lastIndexOf("-", startMethodBody);

        if(startMethodBody < 0) {
            return super.visitInstance_method_definition(ctx);
        }

        translateMethodDefination(ctx.method_definition().method_type(), ctx.method_definition().method_selector(), startMethodBody,
                "", true);

        return super.visitInstance_method_definition(ctx);
    }

    @Override
    public Void visitClass_method_definition(ObjCParser.Class_method_definitionContext ctx) {
        String methodBody = tokens.getText(ctx.getSourceInterval());

        int startMethodBody = outputBuffer.indexOf(methodBody);

        startMethodBody = outputBuffer.lastIndexOf("+", startMethodBody);

        if(startMethodBody < 0) {
            return super.visitClass_method_definition(ctx);
        }

        translateMethodDefination(ctx.method_definition().method_type(), ctx.method_definition().method_selector(), startMethodBody,
                "", true);

        return super.visitClass_method_definition(ctx);
    }

    @Override
    public Void visitMessage_expression(ObjCParser.Message_expressionContext ctx) {
        String text = tokens.getText(ctx.getSourceInterval());
        int start = outputBuffer.indexOf(text);
        if(start < 0) {
            return super.visitMessage_expression(ctx);
        }
        int end = start + text.length();

        String receiver = translateIdentifier(tokens.getText(ctx.receiver().getSourceInterval()));
        String finalMethod = "(" + receiver + translateInvocationOperator(receiver);
        finalMethod += translateMethodNameAndParameters(ctx.message_selector()) + ")";

        outputBuffer.replace(start, end, finalMethod);
        return super.visitMessage_expression(ctx);
    }

    private String translateIdentifier(String receiver) {
        Pattern pattern = Pattern.compile(BEGINS_WITH_2_UPPER_CASE_LETTERS);
        Matcher matcher = pattern.matcher(receiver);
        boolean matches = matcher.matches();
        if(receiver.equals(NS_OBJECT)) {
            return REF;
        } else if(receiver.startsWith(CC)) {
            return COCOS2D + matcher.group(2);
        }
        if(matches) {
            return matcher.group(2);
        }
        return receiver;
    }

    private String translateInvocationOperator(String receiver) {
        Pattern pattern = Pattern.compile(BEGINS_WITH_UPPER_CASE_LETTERS);
        Matcher matcher = pattern.matcher(receiver);
        if(matcher.matches()) {
            //Looks like we are making a static call.
            return "::";
        }
        return "->";
    }

    private String translateMethodNameAndParameters(ObjCParser.Message_selectorContext messageSelectorContext) {
        String finalMethodName = "";
        String finalParameters = "";

        //If this is just a method with no keyword argument we need to get just the selector and use it as the method name.
        if(messageSelectorContext.keyword_argument().size() == 0) {
            finalMethodName = tokens.getText(messageSelectorContext.selector().getSourceInterval());
        }

        //Well this method is made up of multiple parts we will need to upper case the subsequent parts to follow Camel case convention
        //and then pass the parameters as method call.
        for (int i = 0; i< messageSelectorContext.keyword_argument().size(); i++) {
            ObjCParser.Keyword_argumentContext keyword_argumentContext = messageSelectorContext.keyword_argument().get(i);
            String sourceMethod = tokens.getText(keyword_argumentContext.selector().getSourceInterval());
            String sourceParameter = tokens.getText(keyword_argumentContext.expression().getSourceInterval());
            if(i > 0) {
                sourceMethod = sourceMethod.substring(0, 1).toUpperCase() + sourceMethod.substring(1);
                finalParameters += ", ";
            }
            finalMethodName += sourceMethod;
            finalParameters += sourceParameter;
        }

        return finalMethodName + "(" + finalParameters + ")";
    }

    private void translateMethodDefination(ObjCParser.Method_typeContext method_typeContext, ObjCParser.Method_selectorContext method_selectorContext, int startMethodBody, String methodPrefix, boolean shouldAddClassname) {

        String methodTypeString = tokens.getText(method_typeContext.getSourceInterval());
        int startMethodType = outputBuffer.indexOf(methodTypeString, startMethodBody);
        int endMethodType = startMethodType + methodTypeString.length();

        methodTypeString = methodPrefix + methodTypeString.replaceAll("\\(", "").replaceAll("\\)", " ");
        outputBuffer.replace(startMethodBody, endMethodType, methodTypeString);

        String classNamePrefix = shouldAddClassname? className + "::" : "";
        String finalMethodNameParameterTypeAndNames = classNamePrefix + translateMethodNameParameterTypeAndNames(method_selectorContext);

        String methodSelectorString = tokens.getText(method_selectorContext.getSourceInterval());
        int startMethodSelector = outputBuffer.indexOf(methodSelectorString, startMethodBody);
        int endMethodSelector = startMethodSelector + methodSelectorString.length();
        outputBuffer.replace(startMethodSelector, endMethodSelector, finalMethodNameParameterTypeAndNames);
    }

    private String translateMethodNameParameterTypeAndNames(ObjCParser.Method_selectorContext methodSelectorContext) {
        String finalMethodName = "";
        String finalParameters = "";

        //If this is just a method with no keyword argument we need to get just the selector and use it as the method name.
        if(methodSelectorContext.keyword_declarator().size() == 0) {
            finalMethodName = tokens.getText(methodSelectorContext.selector().getSourceInterval());
        }

        //Well this method is made up of multiple parts we will need to upper case the subsequent parts to follow Camel case convention
        //and then pass the parameters as method call.
        for (int i = 0; i< methodSelectorContext.keyword_declarator().size(); i++) {
            ObjCParser.Keyword_declaratorContext keyword_declaratorContext = methodSelectorContext.keyword_declarator().get(i);
            String sourceMethod = tokens.getText(keyword_declaratorContext.selector().getSourceInterval());
            String sourceType = tokens.getText(keyword_declaratorContext.method_type(0).getSourceInterval());
            String sourceParameter = tokens.getText(keyword_declaratorContext.IDENTIFIER().getSourceInterval());
            if(i > 0) {
                sourceMethod = sourceMethod.substring(0, 1).toUpperCase() + sourceMethod.substring(1);
                finalParameters += ", ";
            }
            finalMethodName += sourceMethod;
            finalParameters += translateIdentifier(sourceType.replaceAll("\\(", "").replaceAll("\\)", "")) + " " + sourceParameter;
        }

        return finalMethodName + "(" + finalParameters + ")";
    }

    private String translateLiterals(String source) {
        //Final set of translations to get rid of the imports and supers and self and nil.
        return source.replaceAll("#import", "#include")
                .replaceAll("super", "base")
                .replaceAll("self", "this")
                .replaceAll("nil", "NULL")
                .replaceAll("@public", "public:")
                .replaceAll("@private", "private:")
                .replaceAll("@protected", "protected:")
                ;
    }

    private static String getFileHeader() {
        return
                  "/**\n"
                + " * Autogenerated by ObjCToCppTranslator on "
                + new SimpleDateFormat("dd/MM/yyyy").format(new Date())
                + "\n"
                + " * @author Deep Shah\n"
                + " * (c) 2015 Makkajai\n"
                + " * This code is licensed under MIT license (see LICENSE.txt for details)\n"
                + " */\n\n";
    }

    private String translateClassDecleration() {
        return "class " + translateIdentifier(className) + translateSuperClassDecleration();
    }

    private String translateSuperClassDecleration() {
        if (superClassName == null) {
            return "";
        }

        return " : " + translateIdentifier(superClassName);
    }
}
